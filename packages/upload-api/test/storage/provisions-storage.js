import * as Types from '../../src/types.js'

/**
 *
 * @param {Types.Provision} item
 * @returns {string}
 */
const itemKey = ({ customer, consumer, provider }) =>
  `${customer}:${consumer}@${provider}`

/**
 * @implements {Types.ProvisionsStorage}
 */
export class ProvisionsStorage {
  /**
   *
   * @param {Array<Types.ServiceDID | string>} providers
   */
  constructor(providers = ['did:web:test.web3.storage']) {
    /**
     * @type {Record<string, Types.Provision>}
     */
    this.provisions = {}
    this.providers = /** @type {Types.ServiceDID[]} */ (providers)
  }

  /**
   * @returns {Types.ServiceDID[]}
   */
  get services() {
    return this.providers
  }

  /**
   *
   * @param {Types.DIDKey} consumer
   */
  async getStorageProviders(consumer) {
    return {
      ok: Array.from(
        Object.values(this.provisions).reduce((m, p) => {
          if (p.consumer === consumer) {
            m.add(p.provider)
          }
          return m
        }, new Set())
      ),
    }
  }

  /**
   *
   * @param {Types.DIDKey} consumer
   */
  async hasStorageProvider(consumer) {
    return {
      ok: (await this.getStorageProviders(consumer)).ok.length > 0,
    }
  }

  /**
   *
   * @param {Types.Provision} item
   * @returns the ID generated by the system to identify this "provision"
   */
  async put(item) {
    const key = itemKey(item)
    const storedItem = this.provisions[key]
    if (
      storedItem &&
      (storedItem.provider !== item.provider ||
        storedItem.customer !== item.customer ||
        storedItem.consumer !== item.consumer ||
        storedItem.cause.link() !== item.cause.link())
    ) {
      return {
        error: {
          name: 'Error',
          message: `could not store item - a provision with that key already exists`,
        },
      }
    } else {
      this.provisions[key] = item
      return { ok: { id: key } }
    }
  }

  /**
   *
   * @param {Types.ProviderDID} provider
   * @param {Types.DID<'mailto'>} customer
   * @returns
   */
  async getCustomer(provider, customer) {
    const provisions = Object.values(this.provisions).filter(
      (p) => p.provider === provider && p.customer === customer
    )
    const exists = provisions.length > 0
    if (exists) {
      return {
        ok: {
          did: customer,
          subscriptions: provisions.map(itemKey),
        },
      }
    } else {
      return {
        error: {
          name: 'CustomerNotFound',
          message: 'customer does not exist',
        },
      }
    }
  }

  /**
   *
   * @param {Types.ProviderDID} provider
   * @param {string} subscription
   * @returns
   */
  async getSubscription(provider, subscription) {
    const provision = Object.values(this.provisions).find(
      (p) => p.customer === subscription && p.provider === provider
    )
    if (provision) {
      return { ok: provision }
    } else {
      return {
        error: {
          name: 'SubscriptionNotFound',
          message: `could not find ${subscription}`,
        },
      }
    }
  }

  /**
   *
   * @param {Types.ProviderDID} provider
   * @param {string} consumer
   * @returns
   */
  async getConsumer(provider, consumer) {
    const provision = Object.values(this.provisions).find(
      (p) => p.consumer === consumer && p.provider === provider
    )
    if (provision) {
      return {
        ok: {
          did: provision.consumer,
          allocated: 0,
          limit: 100,
          subscription: itemKey(provision),
          customer: provision.customer,
        },
      }
    } else {
      return {
        error: {
          name: 'ConsumerNotFound',
          message: `could not find ${consumer}`,
        },
      }
    }
  }

  async count() {
    return BigInt(Object.values(this.provisions).length)
  }
}
